##################################################################################
# This was the playground I used for o2. Ended up only using maby 15% of this code!
# Note what is uncommented was more lickely used.
###################################################################################

// version with kinematics
/*

#include "Framework/runDataProcessing.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Common/DataModel/EventSelection.h"

#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"



using namespace o2;
using namespace o2::framework;

//using namespace o2::framework::expressions;


struct MyTask {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, 0, 2*M_PI, "#phi"}}}},
      //{"rapidityHist", "Track Rapidity", {HistType::kTH1F, {{100, -6, 6, "Rapidity"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}}
    }
  };

  void process(aod::Tracks const& tracks) // FwdTracks
  {
    for (auto& track : tracks) {
      //LOGF(info, "Track PT: %f", track.pt());
      //LOGF(info, "Track Phi: %f", track.phi());
      //LOGF(info, "Track Rapidity: %f", track.rapidity());
      //LOGF(info, "Track Eta: %f", track.eta());
      
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      //histos.get<TH1>(HIST("rapidityHist"))->Fill(track.rapidity());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};


WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<MyTask>(cfgc),
  };
}
*/
// version with kinematics and z-vertex
/*

#include "Framework/runDataProcessing.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Common/DataModel/EventSelection.h"

#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"

using namespace o2;
using namespace o2::framework;

struct MyTask {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}
    }
  }

  };void process(aod::Tracks const& tracks, aod::Collisions const& collisions) // FwdTracks
  {
    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }

    // Fill Z vertex position histogram from collision data
    for (auto& collision : collisions) {
      histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());
    }
  }
};

WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<MyTask>(cfgc),
  };
}
*/
// version with kinematics and z-vertex and multiplicity
/*
#include "Framework/runDataProcessing.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Common/DataModel/EventSelection.h"

#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;
*/
//this is the right stuff!!!

/*struct MyTask {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}}
    }
  };
  void process(aod::MFTTracks const& tracks, aod::Collisions const& collisions) // FwdTracks , Tracks
  {

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }

    // Fill Z vertex position histogram from collision data
    for (auto& collision : collisions) {
      histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());
    }
  
  }
};
*/

//This thing workds
/*
struct MyTaskIterative {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;
  
  void process (aod::Collisions::iterator const& collision, aod::FwdTracks const& tracks) // FwdTracks , Tracks
  {
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  
  }
};

struct MyTaskIterative2 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;
  
  void process (aod::Collisions::iterator const& collision, aod::MFTTracks const& tracks) 
  {
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  
  }
};

struct MyTaskIterative3 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;
  
  void process (aod::Collisions::iterator const& collision, aod::Tracks const& tracks) 
  {
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  
  }
};
*/

/*

struct MyTask {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}},
      {"multiplicityHist", "Multiplicity", {HistType::kTH1F, {{100, -0.5, 99.5, "Multiplicity"}}}}
    }
  };

  void process(aod::FwdTracks const& tracks, aod::Collisions const& collisions)
  {
    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }

    // Fill Z vertex position histogram from collision data
    for (auto& collision : collisions) {
      histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());
    }

    // Fill multiplicity histogram
    histos.get<TH1>(HIST("multiplicityHist"))->Fill(tracks.size());
  }
};
*/


/*
struct MultiplicityEventTrackSelection {

  OutputObj<TH1F> multiplicity{TH1F("multiplicity", "multiplicity", 100, -0.5, 99.5)};

  //Filter collisionZFilter = nabs(aod::collision::posZ) < 10.0f;
  //Filter trackFilter = (nabs(aod::track::eta) < 0.8f) && (aod::track::pt > 0.15f) && (requireGlobalTrackInFilter());

  void process(soa::Join<aod::Collisions, aod::EvSels>::iterator const& collision,
               aod::FwdTracks const& tracks)   //FwdTracks...
  {
    
    if (!collision.sel8()) {
      return;
    }

    //LOGP(info, "Collision with {} tracks", tracks.size());
    multiplicity->Fill(tracks.size());
  }
};
*/

/*
struct MultiplicityEventTrackSelection {

  OutputObj<TH1F> multiplicity{TH1F("multiplicity", "multiplicity", 1000, -0.5, 999.5)};

  //Filter collisionZFilter = nabs(aod::collision::posZ) < 10.0f;
  //Filter trackFilter = (nabs(aod::track::eta) < 0.8f) && (aod::track::pt > 0.15f) && (requireGlobalTrackInFilter());

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
               aod::Tracks const& tracks)
  {
  
    LOGP(info, "Collision with {} tracks", tracks.size());
    multiplicity->Fill(tracks.size());
  }
};
*/

//original workflow

/*
WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<MyTaskIterative3>(cfgc), // Process Tracks
    adaptAnalysisTask<MyTaskIterative>(cfgc),  // Process FwdTracks
    adaptAnalysisTask<MyTaskIterative2>(cfgc)  // Process MFTTracks
  };
}
*/


//just p_t
/*
#include "Framework/runDataProcessing.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Common/DataModel/EventSelection.h"
#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;

struct CombinedTask {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
    }
  };

  void process(aod::Collisions::iterator const& collision,
               aod::FwdTracks const& fwdTracks,
               aod::MFTTracks const& mftTracks,
               aod::Tracks const& tracks) {

    // Fill a common histogram for p_t with different colors for each track type
    int color = kRed; // Set a common color for all tracks

    for (auto& track : fwdTracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt(), color);
    }

    color = kBlue; /

    for (auto& track : mftTracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt(), color);
    }

    color = kGreen; 

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt(), color);
    }
  }
};

WorkflowSpec defineDataProcessing(ConfigContext const& cfgc) {
  return WorkflowSpec{
    adaptAnalysisTask<CombinedTask>(cfgc),
  };
}

*/


/*#include "Framework/runDataProcessing.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Common/DataModel/EventSelection.h"

#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;

struct MyTaskIterative {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;
  
  void process (aod::Collisions::iterator const& collision, aod::FwdTracks const& tracks) // FwdTracks , Tracks
  {
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  
  }
};

struct MyTaskIterative2 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;
  
  void process (aod::Collisions::iterator const& collision, aod::MFTTracks const& tracks) 
  {
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  
  }
};

struct MyTaskIterative3 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;
  
  void process (aod::Collisions::iterator const& collision, aod::Tracks const& tracks) 
  {
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  
  }
};

WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<MyTaskIterative>(cfgc),
    adaptAnalysisTask<MyTaskIterative2>(cfgc),
    adaptAnalysisTask<MyTaskIterative3>(cfgc),
    //adaptAnalysisTask<MultiplicityEventTrackSelection>(cfgc),
  };
}*/


//Task that I have now. My MAIN boi
/*
#include "Framework/runDataProcessing.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Common/DataModel/EventSelection.h"

#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;


struct MyTaskIterative {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;
  
  void process (aod::Collisions::iterator const& collision, aod::FwdTracks const& tracks) // FwdTracks , Tracks
  {
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  
  }
};

struct MyTaskIterative2 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;
  
  void process (aod::Collisions::iterator const& collision, aod::MFTTracks const& tracks) 
  {
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  
  }
};

struct MyTaskIterative3 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50,"p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2*M_PI, 2*M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;
  
  void process (aod::Collisions::iterator const& collision, aod::Tracks const& tracks) 
  {
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  
  }
};


WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<MyTaskIterative3>(cfgc), // Process Tracks
    adaptAnalysisTask<MyTaskIterative>(cfgc),  // Process FwdTracks
    adaptAnalysisTask<MyTaskIterative2>(cfgc)  // Process MFTTracks
  };
}
*/

//mult task 
/*
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.
///
/// \brief Example task generating a multiplicity distribution of collisions
///        which pass the INT7 selection and tracks which pass the "isGlobalTrack"
///        selection.
///        Needs to run with event and track selection:
///        o2-analysis-timestamp --aod-file AO2D.root | o2-analysis-event-selection | o2-analysis-trackextension | o2-analysis-trackselection | o2-analysistutorial-multiplicity-event-track-selection
/// \author
/// \since

#include "Framework/runDataProcessing.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Common/DataModel/EventSelection.h"

#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;


struct MultiplicityEventTrackSelection {

  OutputObj<TH1F> multiplicity{TH1F("multiplicity", "multiplicity", 1000, -0.5, 999.5)};

  Filter collisionZFilter = nabs(aod::collision::posZ) < 10.0f;
  Filter trackFilter = (nabs(aod::track::eta) < 0.8f) && (aod::track::pt > 0.15f) && (requireGlobalTrackInFilter());

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
               aod::Tracks const& tracks)
  {
  
    LOGP(info, "Collision with {} tracks", tracks.size());
    multiplicity->Fill(tracks.size());
  }
};

// Workflow definition
WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<MultiplicityEventTrackSelection>(cfgc),
  };
}
*/

#include "Framework/runDataProcessing.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Common/DataModel/EventSelection.h"
#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;


//Fwd TRACK
struct MyTaskFwd {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2 * M_PI, 2 * M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{600, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -20, 20, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;

  Filter collisionZFilter = nabs(aod::collision::posZ) < 10.0f;
  Filter trackFilter = ((aod::fwdtrack::eta >= -4.0f) && (aod::fwdtrack::eta <= -2.5f));

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
               soa::Filtered<aod::FwdTracks> const& tracks)
  {
    if (!collision.sel8()) {
      return;
    }
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());
    //problemo with z-vert

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt()); 
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};

struct MyTaskFwd2 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2 * M_PI, 2 * M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{600, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -20, 20, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;

  Filter collisionZFilter = nabs(aod::collision::posZ) < 20.0f;
  //Filter trackFilter = ((aod::fwdtrack::eta >= -4.0f) && (aod::fwdtrack::eta <= -2.5f));

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
               aod::FwdTracks const& tracks)
  {
    if (!collision.sel8()) {
      return;
    }
    
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());
    //problemo with z-vert

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt()); 
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};


/*
struct MyTaskFwdCUT1 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2 * M_PI, 2 * M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -4, -2.5, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -20, 20, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;

  Filter collisionZFilter = nabs(aod::collision::posZ) < 10.0f;
  Filter trackFilter = ((aod::fwdtrack::eta) >= -4.0f) && ((aod::fwdtrack::eta) <= -2.5f) && (requireGlobalTrackInFilter());

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
               soa::Filtered<soa::Join<aod::FwdTracks, aod::TrackSelection>> const& tracks)
  {
    if (!collision.sel8()) {
      return;
    }
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};
*/

/*
struct MyTaskFwdCUT2 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2 * M_PI, 2 * M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -10, 10, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;

  //Filter collisionZFilter = nabs(aod::collision::posZ) < 10.0f;
  //Filter trackFilter = (aod::track::pt > 0.15f) && (requireGlobalTrackInFilter());

  void process(soa::Join<aod::Collisions, aod::EvSels>::iterator const& collision,
               aod::FwdTracks const& tracks)
  {
    if (!collision.sel8()) {
      return;
    }

    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};

*/

//MFT TRACK
struct MyTaskMFT {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2 * M_PI, 2 * M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{600, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -20, 20, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;

  Filter collisionZFilter = nabs(aod::collision::posZ) < 10.0f;
  Filter trackFilter = ((aod::fwdtrack::eta) >= -3.6f) && ((aod::fwdtrack::eta) <= -2.5f);

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
               soa::Filtered<aod::MFTTracks> const& tracks)
  {
    if (!collision.sel8()) {
      return;
    }
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};

struct MyTaskMFT2 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2 * M_PI, 2 * M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{600, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -20, 20, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;

  Filter collisionZFilter = nabs(aod::collision::posZ) < 20.0f;
  //Filter trackFilter = ((aod::fwdtrack::eta) >= -3.6f) && ((aod::fwdtrack::eta) <= -2.5f);

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
               aod::MFTTracks const& tracks)
  {
    if (!collision.sel8()) {
      return;
    }

    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};



/*
struct MyTaskMFTCUT1 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2 * M_PI, 2 * M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -20, 20, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;

  Filter collisionZFilter = nabs(aod::collision::posZ) < 10.0f;
  Filter trackFilter = ((aod::fwdtrack::eta) >= -3.6f) && ((aod::fwdtrack::eta) <= -2.5f) && (requireGlobalTrackInFilter());

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
               soa::Filtered<soa::Join<aod::MFTTracks, aod::TrackSelection>> const& tracks)
  {
    if (!collision.sel8()) {
      return;
    }
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};



struct MyTaskMFTCUT2 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2 * M_PI, 2 * M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -3.6, -2.5, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -20, 20, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;

 // Filter collisionZFilter = nabs(aod::collision::posZ) < 10.0f;
 // Filter trackFilter = (aod::fwdtrack::eta >= -3.6f) && (aod::fwdtrack::eta <= -2.5f) && (aod::fwdtrack::pt > 0.15f) && (requireGlobalTrackInFilter());

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
               soa::Filtered<aod::MFTTracks> const& tracks)
  {
    if (!collision.sel8()) {
      return;
    }
    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};

*/
//TRACK
struct MyTaskTrack {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2 * M_PI, 2 * M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{600, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -20, 20, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;

  Filter collisionZFilter = nabs(aod::collision::posZ) < 10.0f;
  Filter trackFilter = (requireGlobalTrackInFilter());

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
               soa::Filtered<soa::Join<aod::Tracks, aod::TrackSelection>> const& tracks)
  {
    if (!collision.sel8()) {
      return;
    }

    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};


struct MyTaskTrack2 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2 * M_PI, 2 * M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{600, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -20, 20, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;

  Filter collisionZFilter = nabs(aod::collision::posZ) < 20.0f;
  Filter trackFilter = (requireGlobalTrackInFilter());

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
               aod::Tracks const& tracks)
  {
    if (!collision.sel8()) {
      return;
    }

    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());
    histos.get<TH1>(HIST("zVertexHist"))->Fill(collision.posZ());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};







/*
struct MyTaskTrackCUT2 {
  HistogramRegistry histos{
    "histos",
    {
      {"ptHist", "Track PT", {HistType::kTH1F, {{100, 0, 50, "p_{T} (GeV)"}}}},
      {"phiHist", "Track Phi", {HistType::kTH1F, {{100, -2 * M_PI, 2 * M_PI, "#phi"}}}},
      {"etaHist", "Track Eta", {HistType::kTH1F, {{100, -6, 6, "#eta"}}}},
      {"zVertexHist", "Z Vertex Position", {HistType::kTH1F, {{100, -20, 20, "Z Vertex (cm)"}}}},
      {"multiplicity", "multiplicity", {HistType::kTH1F, {{1000, -0.5, 999.5, "multiplicity"}}}}
    }
  };
  int muonCount = 0;

  //Filter collisionZFilter = nabs(aod::collision::posZ) < 10.0f;
  //Filter trackFilter = (aod::track::pt > 0.15f) && (requireGlobalTrackInFilter());

  void process(soa::Filtered<soa::Join<aod::Collisions, aod::EvSels>>::iterator const& collision,
              aod::Tracks const& tracks)
  {
    if (!collision.sel8()) {
      return;
    }

    histos.get<TH1>(HIST("multiplicity"))->Fill(tracks.size());

    for (auto& track : tracks) {
      histos.get<TH1>(HIST("ptHist"))->Fill(track.pt());
      histos.get<TH1>(HIST("phiHist"))->Fill(track.phi());
      histos.get<TH1>(HIST("etaHist"))->Fill(track.eta());
    }
  }
};

*/

WorkflowSpec defineDataProcessing(ConfigContext const& cfgc) 
{
  return WorkflowSpec{
    adaptAnalysisTask<MyTaskTrack>(cfgc),
    adaptAnalysisTask<MyTaskTrack2>(cfgc),
    adaptAnalysisTask<MyTaskFwd>(cfgc),
    adaptAnalysisTask<MyTaskFwd2>(cfgc),
    adaptAnalysisTask<MyTaskMFT>(cfgc),
    adaptAnalysisTask<MyTaskMFT2>(cfgc),
  };
}
